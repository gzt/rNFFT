% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/NFFT2d.R
\name{nfft_2d}
\alias{nfft_2d}
\alias{ndft_2d}
\alias{nfft_adjoint_2d}
\alias{ndft_adjoint_2d}
\title{2-D NFFT}
\usage{
nfft_2d(x, f_hat)

ndft_2d(x, f_hat)

nfft_adjoint_2d(x, f, N0, N1)

ndft_adjoint_2d(x, f, N0, N1)
}
\arguments{
\item{x}{two dimensional complex vector in \eqn{[-0.5,0.5)^2}}

\item{f_hat}{set of frequencies}

\item{f}{frequencies for adjoint, same length as \code{x}}

\item{N0}{number of frequencies in the first dimension for transform, specified for adjoint.}

\item{N1}{number of frequencies in the second dimension for transform, specified for adjoint.}
}
\description{
2-D Non-equispaced Fourier Tranform
}
\details{
The non-equispaced Fourier transform takes non-uniform samples \eqn{x}
from the $d$-dimensional torus \eqn{[0.5,0.5)^d}.

The NDFT functions compute the Fourier transform directly. This is slow.
The NFFT functions use the FFT to compute this, which should be faster.
The adjoint, in this case, is not the same as the inverse. Solving the
inverse problem requires approximations. Here we present the 2D NDFT,
NFFT, and their adjoints. You most likely want to use the \code{nfft_2d}
and \code{nfft_adjoint_2d} functions rather than the \code{dft} functions.
}
\section{Functions}{
\itemize{
\item \code{ndft_2d}: 

\item \code{nfft_adjoint_2d}: 

\item \code{ndft_adjoint_2d}: 
}}

\examples{
set.seed(20190728)
x <- matrix(runif(2*32*14)-.5, ncol=2, byrow = TRUE)

f_hat = 1:(32*14)
for(i in 1:(32*14)) f_hat[i] = runif(1)*1i + runif(1)
f_hatmatrix = matrix(f_hat, nrow = 32) 
f_vector <- nfft_2d(x, f_hatmatrix)
fd_vector <- ndft_2d(x, f_hatmatrix)
f_vector[1:3]
fd_vector[1:3]
newf_hat <- nfft_adjoint_2d(x,f_vector,32,14)
newf_hat[1,1:7]
newdf_hat <- ndft_adjoint_2d(x,f_vector,32,14)
newdf_hat[1,1:7]
}
